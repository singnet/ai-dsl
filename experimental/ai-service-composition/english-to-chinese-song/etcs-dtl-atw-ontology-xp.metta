;;;;;;;;;
;; Nat ;;
;;;;;;;;;

;; Define Nat
(: Nat Type)
(: Z Nat)
(: S (-> Nat Nat))

;; Define cast functions between Nat and Number
(: fromNumber (-> Number Nat))
(= (fromNumber $n) (if (<= $n 0) Z (S (fromNumber (- $n 1)))))
(: fromNat (-> Nat Number))
(= (fromNat Z) 0)
(= (fromNat (S $k)) (+ 1 (fromNat $k)))

;;;;;;;;;;;;;;;;;;;;;
;; De Bruijn Index ;;
;;;;;;;;;;;;;;;;;;;;;

;; Define DeBruijn type
(: DeBruijn Type)

;; Define DeBruijn constructors
(: z DeBruijn)                        ; Zero
(: s (-> DeBruijn DeBruijn))          ; Successor

;;;;;;;;;;
;; List ;;
;;;;;;;;;;

;; Declaration of List data type and constructors
(: List (-> $a Type))
(: Nil (List $a))
(: Cons (-> $a (List $a) (List $a)))

;;;;;;;;;;;;;;;;;;;;;
;; Match over list ;;
;;;;;;;;;;;;;;;;;;;;;

;; Similar to match but takes a list of terms instead of a space.
(: match' (-> (List Atom) $a $a $a))
(= (match' Nil $pattern $rewrite) (empty))
(= (match' (Cons $head $tail) $pattern $rewrite) (let $pattern $head $rewrite))
(= (match' (Cons $head $tail) $pattern $rewrite) (match' $tail $pattern $rewrite))

;; Test match' on empty list
!(assertEqualToResult
  (match' Nil ($x $y) ($y $x))
  ())

;; Test match' on singleton
!(assertEqual
  (match' (Cons (A B) Nil) ($x $y) ($y $x))
  (B A))

;; Test match' on pair
!(assertEqualToResult
  (match' (Cons (A B) (Cons (C D) Nil)) ($x $y) ($y $x))
  ((B A)
   (D C)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Knowledge and rule base ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

!(bind! &kb (new-space))

;;;;;;;;;;;;;;;
;; Subtyping ;;
;;;;;;;;;;;;;;;

;; Notations:
;;
;; 1. Variables in upper case, like `$T`, tend to correspond to types.
;; 2. Variables in lower case, like `$t`, tend to correspond to terms.
;; 3. In the rule names:
;; 3.1. ST stands for SubTyping,
;; 3.2. Refl for Reflexive,
;; 3.3. Trans for transitive,
;; 3.4. Cov for contravariant.

;; ;; Subtyping is relexive
;; !(add-atom &kb (: STRefl (<: $T $T)))

;; Subtyping is transitive
!(add-atom &kb (: STTrans (-> (: $prf1 (<: $S $T))
                              (-> (: $prf2 (<: $T $U))
                                  (<: $S $U)))))

;; ;; Subtyping of function types is contravariant over inputs and
;; ;; covariant over outputs.
;; !(add-atom &kb (: STConv (-> (: $prf1 (<: $T1 $S1))
;;                              (-> (: $prf2 (<: $S2 $T2))
;;                                  (<: (-> $S1 $S2) (-> $T1 $T2))))))

;; Relationship between subtyping and type assume explicit coercion.
;; That is if a term `t` is of type `S` a subtype of `T`, then
;; `(coerce proof_S<:T t)` is of type `T`, where `proof_S<:T` is a
;; proof that `S` is a subtype of `T`.
!(add-atom &kb (: coerce (-> (: $prf (<: $S $T))
                             (-> (: $s $S)
                                 $T))))

;;;;;;;;;;;;;;
;; Ontology ;;
;;;;;;;;;;;;;;

;; The ontology tries to be based on existing ontologies when
;; possible.  See the following discussion for a list of ontologies
;;
;; https://github.com/singnet/ai-dsl/discussions/18

;; Language
!(add-atom &kb (: NS (<: NaturalLanguage String)))             ; SUMO

;; Text
!(add-atom &kb (: TS (<: Text String)))
!(add-atom &kb (: TIT (<: (TextIn $l) Text)))

;; URL
!(add-atom &kb (: US (<: UniformResourceLocator String)))      ; SUMO
!(add-atom &kb (: UTU (<: (UniformResourceLocatorOfType $t) UniformResourceLocator)))

;; MIDI
!(add-atom &kb (: MB (<: MusicalInstrumentDigitalInterface Bytes)))

;; Audio
!(add-atom &kb (: AB (<: Audio Bytes)))
!(add-atom &kb (: IA (<: Instrumental Audio)))
!(add-atom &kb (: VA (<: Vocals Audio)))
!(add-atom &kb (: VIV (<: (VocalsIn $l) Vocals)))
!(add-atom &kb (: SIA (<: (SongIn $l) Audio)))

;; TODO: for now we paste the content of
;; english-song-to-chinese-song-services.metta here because the import
;; operation imports the stdlib as well and let stdlib functions being
;; used as rules and axioms by the backward chainer.
;;
;; Also, for the sake of simplicity the names have been shorten by
;; removing the organization.  For instance
;;
;; naint.machine-translation.Input
;;
;; becomes
;;
;; machine-translation.Input

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Services involved in creating a composite service to turn English
;; singing into Chinese singing.
;;
;; The service specifications are obtained from the output of
;;
;; ./gen-snet-marketplace-metta.sh naint.machine-translation naint.midi2voice-zh snet.sound-spleeter snet.speech-recognition
;;
;; then curated to retain only the information about the type
;; signatures of service calls.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MeTTa representation, generated by protobuf-metta
;;
;; Protobuf file: translate.proto
;; Protobuf syntax: proto3
;; Prefix: naint.machine-translation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Define machine-translation.translate service method
!(add-atom &kb (: machine-translation.translate
                  (-> (: $in-nl NaturalLanguage)
                      (-> (: $out-nl NaturalLanguage)
                          (-> (: $url (UniformResourceLocatorOfType (TextIn $in-nl)))
                              (TextIn $out-nl))))))

;; We add an extra micro service to turn Text into a URL
!(add-atom &kb (: upload (-> (: $x $a)
                             (UniformResourceLocatorOfType $a))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MeTTa representation, generated by protobuf-metta
;;
;; Protobuf file: singingZH.proto
;; Protobuf syntax: proto3
;; Protobuf package: singingZH
;; Prefix: midi2voice-zh
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Define midi2voice-zh.singingZH service method
!(add-atom &kb (: midi2voice-zh.singingZH
                  (-> (: $text (TextIn "Chinese"))
                      (-> (: $midi MusicalInstrumentDigitalInterface)
                          (VocalsIn "Chinese")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MeTTa representation, generated by protobuf-metta
;;
;; Protobuf file: sound_spleeter.proto
;; Protobuf syntax: proto3
;; Prefix: snet.sound-spleeter
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;
;; Message Types ;;
;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;
;; Output ;;
;;;;;;;;;;;;

;; Define sound-spleeter.Output constuctor
!(add-atom &kb (: sound-spleeter.MkOutput
                  (-> (: $voc Vocals)
                      (-> (: $inst Instrumental)
                          sound-spleeter.Output))))

;; Define sound-spleeter.Output access functions

;; Define sound-spleeter.Output.vocals
!(add-atom &kb (: sound-spleeter.Output.vocals
                  (-> (: $out sound-spleeter.Output)
                      Vocals)))

;; Define sound-spleeter.Output.accomp
!(add-atom &kb (: sound-spleeter.Output.accomp
                  (-> (: $out sound-spleeter.Output)
                      Instrumental)))

;; DTL version of Output

;; Define sound-spleeter.DTLOutput constuctor
!(add-atom &kb (: sound-spleeter.MkDTLOutput
                  (-> (: $l NaturalLanguage)
                      (-> (: $voc (VocalsIn $l))
                          (-> (: $inst Instrumental)
                              (sound-spleeter.DTLOutput $l))))))

;; Define sound-spleeter.DTLOutput access functions

;; Define sound-spleeter.DTLOutput.vocals
!(add-atom &kb (: sound-spleeter.DTLOutput.vocals
                  (-> (: $out (sound-spleeter.DTLOutput $l))
                      (VocalsIn $l))))

;; Define sound-spleeter.OutputDTL.accomp
!(add-atom &kb (: sound-spleeter.DTLOutput.accomp
                  (-> (: $out (sound-spleeter.DTLOutput $l))
                      Instrumental)))

;;;;;;;;;;;;;;
;; Services ;;
;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;
;; SoundSpleeter ;;
;;;;;;;;;;;;;;;;;;;

;; Define sound-spleeter.spleeter service method
!(add-atom &kb (: sound-spleeter.spleeter
                  (-> (: $audio Audio)
                      ;; We reuse the spleeter Output type to hold
                      ;; a pair of Audio
                      sound-spleeter.Output)))

;; Define DTL version of sound-spleeter.spleeter
!(add-atom &kb (: sound-spleeter.spleeter
                  (-> (: $song (SongIn $l))
                      ;; We reuse the spleeter Output type to hold
                      ;; a pair of Audio
                      (sound-spleeter.DTLOutput $l))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MeTTa representation, generated by protobuf-metta
;;
;; Protobuf file: asr.proto
;; Protobuf syntax: proto3
;; Protobuf package: asr
;; Prefix: speech-recognition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Define speech-recognition.s2t service method
!(add-atom &kb (: speech-recognition.s2t
                  (-> (: $audio Audio)
                      (TextIn "English"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Handwrite missing services, ToMidi and Mixer ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;
;; ToMidi ;;
;;;;;;;;;;;;

;; Method
!(add-atom &kb (: tomidi.a2m
                  (-> (: $audio Audio)
                      MusicalInstrumentDigitalInterface)))

;;;;;;;;;;;
;; Mixer ;;
;;;;;;;;;;;

;; Method
!(add-atom &kb (: mixer.mix (-> (: $audio1 Audio)
                                (-> (: $audio2 Audio)
                                    Audio))))

;; DTL version
!(add-atom &kb (: mixer.mix (-> (: $inst Instrumental)
                                (-> (: $voc (VocalsIn $l))
                                    (SongIn $l)))))

;; Acrobatic attempt to specify a property about mixing without
;; overloading the type signature of the mixer
;;
;; (: $mixer Mixer) -> ($mixer (c1 $x) (c2 $y)) and (: $x (VocalsIn $l)) (: $y Instrumental) -> $z === mix ...) -> (: $z (SongIn $l))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Other type definitions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; English language string
!(add-atom &kb (: "English" NaturalLanguage))

;; Chinese language string
!(add-atom &kb (: "Chinese" NaturalLanguage))

;;;;;;;;;;;;;;;;;;;;;;
;; Backward chainer ;;
;;;;;;;;;;;;;;;;;;;;;;

;; The following code is copied from NEXT.

;; Curried Backward Chainer with lambda abstraction and dependent
;; types.  A lambda abstraction is represented by
;;
;; (λ <INDEX> <BODY>)
;;
;; where <INDEX> is a De Bruijn index as define above, such as z or
;; (s z), and <BODY> is a term possibly containing <INDEX>.  Note
;; that the use of De Bruijn index in lambda abstraction is somewhat
;; unconventional here.  It differs from what is described in
;; https://en.wikipedia.org/wiki/De_Bruijn_index in three ways:
;;
;; 1. The index is explicitely attached to a λ by being its first
;;    argument.  For instance the lambda term λx.x, which would
;;    traditionally be represented by λ1 using De Bruijn index, would
;;    be represented here by the MeTTa term (λ z z).
;;
;; 2. As seen in the example above the index here starts at 0,
;;    represented by z, instead of 1.
;;
;; 3. The index increases as the lambda abstraction gets deeper.  For
;;    instance λx.λy.x, which would traditionally be represented by
;;    λλ2 using De Bruijn index, is represented here by the MeTTa term
;;    (λ z (λ (s z) z).
;;
;; This differences are due to the way the proof abstraction recursive
;; step is defined in the bc, as well as the need for having non
;; overlapping pattern matching between the two recursive steps.
;; Specifically, if λ had only one argument, then (λ <BODY>) would
;; overlap with (<ABS> <ARG>).  Having λ take 2 arguments instead of 1
;; has the disadvantage of making lambda abstraction not as compact.
;; On the flip side, the benefit is that the scope of an index is
;; easier to track.
;;
;; The arguments of the backward chainer are:
;;
;; * Knowledge base: pointer to a space containing axioms and rules in
;;   the format (: <NAME> <RULE>).  Note that rules are explicitely
;;   curried, meaning that a rule with two premises is represented by
;;
;;   (: <NAME> (-> <PREMISE1> (-> <PREMISE2> <CONCLUSION>)))
;;
;;   In addition, each premise must be an inline typing relationship,
;;   to represent dependent types.  It should be noted that such
;;   typing relationship must be provided even if the witness is not
;;   present in the rest of the definition.  For instance <PREMISE1>
;;   would have the format
;;
;;   (: <TERM1> <TYPE1>)
;;
;; * Environment: a list of typing relationship between De Bruijn
;;   index and type, such as
;;
;;   (Cons (: z String) (Cons (: (s z) Number) Nil))
;;
;; * De Bruijn Index: De Bruijn Index to use if a lambda abstraction
;;   is introduced.
;;
;; * Maximum depth: maximum depth of the generated proof tree.
;;
;; * Query: a metta term of the form (: <PROOF> <THEOREM>) where
;;   <PROOF> and <THEOREM> may contain free variables that may be
;;   filled by the backward chainer.  Note that for arguments of
;;   applications must be type annotated (unknowns types are of course
;;   allowed).  For instance the following query
;;
;;   (: (ModusPonens ab) $thrm)
;;
;;   would not work, instead one needs to provide
;;
;;   (: (ModusPonens (: ab $lemma)) $thrm)
;;
;; A result is the query with its variables grounded, fully or
;; partially.  If multiple results are possible, they are returned as
;; a superposition.
;;
;; As explained, the proof arguments must be type annotated.  Without
;; such type annotation, lambda abstraction sometimes leads to
;; incorrect results.  It is suspected to come from the fact that
;; otherwise the proof application recursive step loses bindings about
;; the premise.  Having annotated proof is however a good thing, to
;; display a proof tree and to have an indepth view into the proof.
;; In order to remove (resp. add) type annotation one can use
;; remove-type-annotation (resp. add-type-annotation).
(: bc (-> $a                            ; Knowledge base space
          $b                            ; Environment
          DeBruijn                      ; De Bruijn Index
          Nat                           ; Maximum depth
          $c                            ; Query
          $c))                          ; Result

;; Base cases

;; Match the knowledge base
(= (bc $kb $env $idx $_ (: $prf $thrm))
   (match $kb (: $prf $thrm) (: $prf $thrm)))
;; Match the environment
(= (bc $kb $env $idx $_ (: $prf $thrm))
   (match' $env (: $prf $thrm) (: $prf $thrm)))

;; Recursive steps

;; Proof application
(= (bc $kb $env $idx (S $k) (: ($prfabs (: $prfarg $prms)) $thrm))
   (let* (((: $prfabs (-> (: $prfarg $prms) $thrm))
           (bc $kb $env $idx $k (: $prfabs (-> (: $prfarg $prms) $thrm))))
          ((: $prfarg $prms)
           (bc $kb $env $idx $k (: $prfarg $prms))))
     (: ($prfabs (: $prfarg $prms)) $thrm)))
;; Proof abstraction
(= (bc $kb $env $idx (S $k) (: (λ $idx $prfbdy) (-> (: $prfarg $prms) $thrm)))
   (let (: $prfbdy $thrm)
     (bc $kb (Cons (: $idx $prms) $env) (s $idx) $k (: $prfbdy $thrm))
     (: (λ $idx $prfbdy) (-> (: $prfarg $prms) $thrm))))

;;;;;;;;;;;;;;;;;;;;;
;; Remove/add type ;;
;;;;;;;;;;;;;;;;;;;;;

;; Remove type annotations from a query.
;;
;; For instance
;;
;; (remove-type-annotation (: ((ModusPonens (: ab (→ A B))) (: a A)) B))
;;
;; outputs
;;
;; ((ModusPonens ab) a)
;; (: remove-type-annotation (-> $a $a))
(= (remove-type-annotation $term)
   (case (get-metatype $term)
     ((Symbol $term)
      (Grounded $term)
      (Variable $term)
      (Expression (case $term
                    ;; Only covers up to trinary expression because
                    ;; for now the bc is not supposed to generate
                    ;; n-ary expression where n is greater 3.
                    ((() ())
                     (($x) ((remove-type-annotation $x)))
                     (($x $y) ((remove-type-annotation $x) (remove-type-annotation $y)))
                     (($x $y $z) (if (== $x :)
                                     (remove-type-annotation $y)
                                     ((remove-type-annotation $x)
                                      (remove-type-annotation $y)
                                      (remove-type-annotation $z))))
                     ($_ $_)))))))

;; Add type missing annotation to be compatible with bc query format.
;; Whatever is missing is only added as variables, not inferred, for
;; that one may use the bc.  Note that the first annotation must be
;; provided manually
;;
;; For instance
;;
;; (add-type-annotation ((ModusPonens ab) a))
;;
;; only outputs
;;
;; ((ModusPonens (: ab $t#1)) (: a $t#2))
;;
;; not
;;
;; (: ((ModusPonens (: ab $t#1)) (: a $t#2)) $t#3)
;;
;; That is because add-type-annotation can only detect application, that is a
;; term of the form (<ABS> <ARG>) to add the type annotation to <ARG>.
;;
;; NEXT: must keep track of the existing type to remain consistant.
(: add-type-annotation (-> $a $a))
(= (add-type-annotation $term)
   (case (get-metatype $term)
     ((Symbol $term)
      (Grounded $term)
      (Variable $term)
      (Expression (case $term
                    ((() ())
                     (($x) ($x))
                     (($x $y) (if (== $x s)
                                  ;; Treat De Bruijn index atomically
                                  $term
                                  ;; Add type annotation to argument of application
                                  (let $νx (add-type-annotation $x) ($νx (: (add-type-annotation $y) $t)))))
                     (($x $y $z) (if (== $x :)
                                     ;; Already a type annotation, recurse only on $y
                                     (: (add-type-annotation $y) $z)
                                     (if (== $x λ)
                                         ;; Recurse only on body of lambda abstraction
                                         (λ $y (add-type-annotation $z))
                                         $term)))
                     ($_ $_)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; MeTTa to λ-calculus ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

;; The following code is borrowed from calculi-converter.metta in the
;; chaining repository.

;; Convert metta to lambda calculus with De Bruijn indices.  It takes
;; in arguments
;;
;; 1. De Bruijn index to use for the next abstraction
;;
;; 2. MeTTa term.  Built-in operators such as let must be previously
;;    converted into LET to avoid spontaneous reduction.  NEXT: maybe
;;    we actually don't.
(: mt2lc (-> DeBruijn Atom Atom))
(= (mt2lc $idx $term)
   (case (get-metatype $term)
     ((Symbol $term)
      (Grounded $term)
      (Variable $term)
      (Expression (case $term
                    (;; Empty
                     (() ())
                     ;; LET
                     ((LET $x $y $f) (let* (($x $idx)
                                            ($νf (mt2lc (s $idx) $f))
                                            ($νy (mt2lc $idx $y)))
                                       ((λ $x $νf) $νy)))
                     ;; Application
                     (($f $x) ((mt2lc $idx $f) (mt2lc $idx $x)))
                     ;; Other
                     ($term $term)))))))

;;;;;;;;;;
;; Test ;;
;;;;;;;;;;

;; The following MeTTa program represents the AI service composition
;; for the English to Chinese song translation.
;;
;; (= (english-song-to-chinese-song $input)
;;    (let* (($spleeter-output (sound-spleeter.spleeter $input))
;;           ($english-vocals (sound-spleeter.Output.vocals $spleeter-output))
;;           ($chinese-lyrics (((machine-translation.translate "English") "Chinese")
;;                             (upload (speech-recognition.s2t $english-vocals)))))
;;      ((mixer.mix
;;        ((coerce $prf1) (sound-spleeter.Output.accomp $spleeter-output)))
;;       ((midi2voice-zh.singingZH $chinese-lyrics)
;;        (tomidi.a2m ((coerce $prf2) $english-vocals))))))

;; The following MeTTa program represents the AI service composition
;; for the English to Chinese song translation, but uses let instead
;; of let*.
;;
;; (= (english-song-to-chinese-song $input)
;;    (let $spleeter-output (sound-spleeter.spleeter $input)
;;      (let $english-vocals (sound-spleeter.Output.vocals $spleeter-output)
;;        (let $chinese-lyrics (((machine-translation.translate "English") "Chinese")
;;                              (upload (speech-recognition.s2t $english-vocals)))
;;          ((mixer.mix
;;            ((coerce $prf1) (sound-spleeter.Output.accomp $spleeter-output)))
;;           ((midi2voice-zh.singingZH $chinese-lyrics)
;;            (tomidi.a2m ((coerce $prf2) $english-vocals))))))))

;; The following lambda term has been obtained by converting MeTTa to
;; lambda-calculus as follow
;;
;; !(mt2lc (s z)
;;         (LET $spleeter-output (sound-spleeter.spleeter $input)
;;           (LET $english-vocals (sound-spleeter.Output.vocals $spleeter-output)
;;             (LET $chinese-lyrics (((machine-translation.translate "English") "Chinese")
;;                                   (upload (speech-recognition.s2t $english-vocals)))
;;                  ((mixer.mix
;;                    ((coerce $prf1) (sound-spleeter.Output.accomp $spleeter-output)))
;;                   ((midi2voice-zh.singingZH $chinese-lyrics)
;;                    (tomidi.a2m ((coerce $prf2) $english-vocals))))))))
;;
;; and wrapping $input into a lambda abstraction using z as its
;; corresponding De Bruijn index, which gives us
;;
;; (λ z
;;   ((λ (s z)
;;      ((λ (s (s z))
;;         ((λ (s (s (s z)))
;;            ((mixer.mix
;;              ((coerce $prf1) (sound-spleeter.Output.accomp (s z))))
;;             ((midi2voice-zh.singingZH (s (s (s z))))
;;              (tomidi.a2m ((coerce $prf2) (s (s z)))))))
;;          (((machine-translation.translate "English") "Chinese")
;;           (upload (speech-recognition.s2t (s (s z)))))))
;;       (sound-spleeter.Output.vocals (s z)))) (sound-spleeter.spleeter z)))

;; The we add type annotations, as it required by the backward
;; chainer, by calling add-type-annotation as follows
;;
;; !(add-type-annotation
;;   (λ z
;;     ((λ (s z)
;;        ((λ (s (s z))
;;           ((λ (s (s (s z)))
;;              ((mixer.mix
;;                ((coerce $prf1) (sound-spleeter.Output.accomp (s z))))
;;               ((midi2voice-zh.singingZH (s (s (s z))))
;;                (tomidi.a2m ((coerce $prf2) (s (s z)))))))
;;            (((machine-translation.translate "English") "Chinese")
;;             (upload (speech-recognition.s2t (s (s z)))))))
;;         (sound-spleeter.Output.vocals (s z)))) (sound-spleeter.spleeter z))))
;;
;; which gives us
;;
;; (λ z
;;   ((λ (s z)
;;      ((λ (s (s z))
;;         ((λ (s (s (s z)))
;;            ((mixer.mix
;;              (: ((coerce (: $prf1 $t1344236))
;;                  (: (sound-spleeter.Output.accomp (: (s z) $t1368977))
;;                     $t1324258))
;;                 $t1306474))
;;             (: ((midi2voice-zh.singingZH (: (s (s (s z))) $t1426175))
;;                 (: (tomidi.a2m (: ((coerce (: $prf2 $t1499053))
;;                                    (: (s (s z))
;;                                       $t1478911))
;;                                   $t1460881))
;;                    $t1405639))
;;                $t1278338)))
;;          (: (((machine-translation.translate
;;                (: "English" $t1632159))
;;               (: "Chinese" $t1623369))
;;              (: (upload (: (speech-recognition.s2t (: (s (s z)) $t1674614))
;;                            $t1658822))
;;                 $t1608997))
;;             $t1174780)))
;;       (: (sound-spleeter.Output.vocals
;;           (: (s z) $t1999388))
;;          $t980175)))
;;    (: (sound-spleeter.spleeter (: z $t3200004)) $t527299)))

;; Type check part of the English to Chinese singing AI service composition
;; TODO: re-enable once alpha-equivalence is supported
;; !(assertEqualToResult
  !(bc &kb Nil z (fromNumber 0) (: sound-spleeter.spleeter $thrm))
  ;; ((: sound-spleeter.spleeter
  ;;     (-> (: $song (SongIn $l))
  ;;         (sound-spleeter.DTLOutput $l)))
  ;;  (: sound-spleeter.spleeter
  ;;     (-> (: $audio Audio)
  ;;         sound-spleeter.Output))))

;; Type check part of the English to Chinese singing AI service composition
;; TODO: re-enable once alpha-equivalence is supported
;; !(assertEqualToResult
  !(bc &kb
      (Cons (: z $a) Nil)
      z
      (fromNumber 1)
      (: (sound-spleeter.spleeter (: z $a)) $thrm))
  ;; ((: (sound-spleeter.spleeter (: z Audio)) sound-spleeter.Output)
  ;;  (: (sound-spleeter.spleeter (: z (SongIn $l))) (sound-spleeter.DTLOutput $l))))

;; Find proof that (VocalsIn $l) is a subtype of Audio
!(assertEqual
  (bc &kb Nil z (fromNumber 2) (: $prf (<: (VocalsIn $l) Audio)))
  (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio))) (<: (VocalsIn $l) Audio)))

;; Type check part of the English to Chinese singing AI service composition
;; TODO: need alpha-equivalence to re-enable assertEqual
;; !(assertEqual
  !(bc &kb (Cons (: (s z) $t1368977) Nil) z (fromNumber 2)
      (: (sound-spleeter.DTLOutput.accomp (: (s z) $t1368977))
         $t1324258))
  ;; (: (sound-spleeter.DTLOutput.accomp
  ;;     (: (s z) (sound-spleeter.DTLOutput $l)))
  ;;    Instrumental))

;; Type check part of the English to Chinese singing AI service composition
;; TODO: need alpha-equivalence to re-enable assertEqual
;; !(assertEqual
  !(bc &kb (Cons (: (s z) $t1368977) Nil) z (fromNumber 3)
      (: (mixer.mix
          (: (sound-spleeter.DTLOutput.accomp (: (s z) $t1368977))
             $t1324258))
         $thrm))
  ;; (: (mixer.mix
  ;;     (: (sound-spleeter.DTLOutput.accomp
  ;;         (: (s z) (sound-spleeter.DTLOutput $l#6001)))
  ;;        Instrumental))
  ;;    (-> (: $voc#1866 (VocalsIn $l#1867)) (SongIn $l#1867))))

;; Type check part of the English to Chinese singing AI service
;; composition.  Same as above but use the version of mixer.mix that
;; takes Instrumental directly as argument
;;
;; TODO: need to use alpha-equivalence to re-enable assertEqual
;; !(assertEqual
  !(bc &kb (Cons (: (s z) $t1368977) Nil) z (fromNumber 2)
      (: (mixer.mix
          (: (sound-spleeter.DTLOutput.accomp (: (s z) $t1368977)) $t1324258))
         $thrm))
  ;; (: (mixer.mix
  ;;     (: (sound-spleeter.DTLOutput.accomp
  ;;         (: (s z) (sound-spleeter.DTLOutput $l6431)))
  ;;        Instrumental))
  ;;    (-> (: $voc2542 (VocalsIn $l2543)) (SongIn $l2543))))

;; Type check part of the English to Chinese singing AI service
;; composition
!(assertEqual
  (bc &kb
      (Cons (: (s (s z)) $t1478911)
            (Cons (: (s (s (s z))) $t1426175) Nil))
      z
      (fromNumber 6)
      (: ((midi2voice-zh.singingZH (: (s (s (s z))) $t1426175))
          (: (tomidi.a2m (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
                                        (<: (VocalsIn $l) Audio)))
                             (: (s (s z)) $t1478911))
                            $t1460881))
             $t1405639))
         $t1278338))
  (: ((midi2voice-zh.singingZH (: (s (s (s z))) (TextIn "Chinese")))
      (: (tomidi.a2m (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
                                    (<: (VocalsIn $l) Audio)))
                         (: (s (s z)) (VocalsIn $l)))
                        Audio))
         MusicalInstrumentDigitalInterface))
     (VocalsIn "Chinese")))

;; Type check part of the English to Chinese singing AI service
;; composition
;; TODO: re-enable when we have alpha-equivalent assert
;; !(assertEqual
  !(bc &kb
      (Cons (: (s z) $t1368977)
            (Cons (: (s (s z)) $t1478911)
                  Nil))
      (s (s (s z)))
      (fromNumber 8)
      (: (λ (s (s (s z)))
           ((mixer.mix
             (: (sound-spleeter.DTLOutput.accomp (: (s z) $t1368977)) $t1324258))
            (: ((midi2voice-zh.singingZH (: (s (s (s z))) $t1426175))
                (: (tomidi.a2m (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
                                              (<: (VocalsIn $l) Audio)))
                                   (: (s (s z)) $t1478911))
                                  $t1460881))
                   $t1405639))
               $t1278338)))
         $thrm))
  ;; (: (λ (s (s (s z)))
  ;;      ((mixer.mix
  ;;        (: (sound-spleeter.DTLOutput.accomp (: (s z) (sound-spleeter.DTLOutput $l#41937)))
  ;;           Instrumental))
  ;;       (: ((midi2voice-zh.singingZH (: (s (s (s z))) (TextIn "Chinese")))
  ;;           (: (tomidi.a2m (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
  ;;                                         (<: (VocalsIn $l) Audio)))
  ;;                              (: (s (s z)) (VocalsIn $l))) Audio))
  ;;              MusicalInstrumentDigitalInterface))
  ;;          (VocalsIn "Chinese"))))
  ;;    (-> (: $prfarg (TextIn "Chinese")) (SongIn "Chinese"))))

;; Type check part of the English to Chinese singing AI service composition
!(assertEqual
  (bc &kb
      (Cons (: (s (s z)) $t1674614) Nil)
      z
      (fromNumber 3)
      (: (((machine-translation.translate
            (: "English" $t1632159))
           (: "Chinese" $t1623369))
          (: (upload (: (speech-recognition.s2t (: (s (s z)) $t1674614))
                        $t1658822))
             $t1608997))
         $t1174780))
  (: (((machine-translation.translate
        (: "English" NaturalLanguage))
       (: "Chinese" NaturalLanguage))
      (: (upload (: (speech-recognition.s2t (: (s (s z)) Audio))
                    (TextIn "English")))
         (UniformResourceLocatorOfType (TextIn "English"))))
     (TextIn "Chinese")))

;; Type check toy function application where all knowledge is in the
;; environment
!(assertEqual
  (bc &kb
      (Cons (: foo (-> (: $x (TextIn "Chinese")) Audio))
            (Cons (: "你好世界!" (TextIn "Chinese"))
                  Nil))
      z
      (fromNumber 1)
      (: (foo (: "你好世界!" (TextIn "Chinese"))) $thrm))
  (: (foo (: "你好世界!" (TextIn "Chinese"))) Audio))

;; Type check toy unanimous function application where all knowledge
;; is in the environment
!(assertEqual
  (bc &kb
      (Cons (: foo (-> (: $x (TextIn "Chinese")) Audio))
            (Cons (: "你好世界!" (TextIn "Chinese"))
                  Nil))
      z
      (fromNumber 3)
      (: ((λ z (foo (: z (TextIn "Chinese"))))
          (: "你好世界!" (TextIn "Chinese")))
         $thrm))
  (: ((λ z (foo (: z (TextIn "Chinese"))))
      (: "你好世界!" (TextIn "Chinese")))
     Audio))

;; Type check part of the English to Chinese singing AI service
;; composition
;; !(assertEqual
  !(bc &kb
      (Cons (: (s z) $t1368977)
            (Cons (: (s (s z)) $t1478911)
                  Nil))
      (s (s (s z)))
      (fromNumber 9)
      (: ((λ (s (s (s z)))
            ((mixer.mix
              (: (sound-spleeter.DTLOutput.accomp (: (s z) $t1368977))
                 $t1306474))
             (: ((midi2voice-zh.singingZH (: (s (s (s z))) $t1426175))
                 (: (tomidi.a2m (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
                                               (<: (VocalsIn $l) Audio)))
                                    (: (s (s z)) $t1478911))
                                   $t1460881))
                    $t1405639))
                $t1278338)))
          (: (((machine-translation.translate
                (: "English" $t1632159))
               (: "Chinese" $t1623369))
              (: (upload (: (speech-recognition.s2t
                             (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
                                            (<: (VocalsIn $l) Audio)))
                                 (: (s (s z)) $t1478911))
                                $t1234567))
                            $t1658822))
                 $t1608997))
             $t1174780))
         $thrm))
  ;; (: ((λ (s (s (s z)))
  ;;       ((mixer.mix
  ;;         (: (sound-spleeter.DTLOutput.accomp (: (s z) (sound-spleeter.DTLOutput $l)))
  ;;            Instrumental))
  ;;        (: ((midi2voice-zh.singingZH (: (s (s (s z))) (TextIn "Chinese")))
  ;;            (: (tomidi.a2m (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
  ;;                                          (<: (VocalsIn $l) Audio)))
  ;;                               (: (s (s z)) (VocalsIn $l))) Audio))
  ;;               MusicalInstrumentDigitalInterface))
  ;;           (VocalsIn "Chinese"))))
  ;;     (: (((machine-translation.translate (: "English" NaturalLanguage))
  ;;          (: "Chinese" NaturalLanguage))
  ;;         (: (upload (: (speech-recognition.s2t
  ;;                        (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
  ;;                                       (<: (VocalsIn $l) Audio)))
  ;;                            (: (s (s z)) (VocalsIn $l))) Audio))
  ;;                       (TextIn "English")))
  ;;            (UniformResourceLocatorOfType (TextIn "English"))))
  ;;        (TextIn "Chinese")))
  ;;    (SongIn "Chinese")))

;; Type check part of the English to Chinese singing AI service composition
!(assertEqual
  (bc &kb
      (Cons (: (s z) $t1368977) Nil)
      (s (s z))
      (fromNumber 11)
      (: ((λ (s (s z))
            ((λ (s (s (s z)))
               ((mixer.mix
                 (: (sound-spleeter.DTLOutput.accomp (: (s z) $t1368977))
                    $t1324258))
                (: ((midi2voice-zh.singingZH (: (s (s (s z))) $t1426175))
                    (: (tomidi.a2m (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
                                                  (<: (VocalsIn $l) Audio)))
                                       (: (s (s z)) $t1478911))
                                      $t1460881))
                       $t1405639))
                   $t1278338)))
             (: (((machine-translation.translate
                   (: "English" $t1632159))
                  (: "Chinese" $t1623369))
                 (: (upload (: (speech-recognition.s2t
                                (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
                                               (<: (VocalsIn $l) Audio)))
                                    (: (s (s z)) $t1478911))
                                   $t1234567))
                               $t1658822))
                    $t1608997))
                $t1174780)))
          (: (sound-spleeter.DTLOutput.vocals
              (: (s z) $t1368977))
             $t980175))
         $thrm))
  (: ((λ (s (s z))
        ((λ (s (s (s z)))
           ((mixer.mix
             (: (sound-spleeter.DTLOutput.accomp (: (s z) (sound-spleeter.DTLOutput $l))) Instrumental))
            (: ((midi2voice-zh.singingZH (: (s (s (s z))) (TextIn "Chinese")))
                (: (tomidi.a2m
                    (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
                                   (<: (VocalsIn $l) Audio)))
                        (: (s (s z)) (VocalsIn $l))) Audio))
                   MusicalInstrumentDigitalInterface))
               (VocalsIn "Chinese"))))
         (: (((machine-translation.translate (: "English" NaturalLanguage))
              (: "Chinese" NaturalLanguage))
             (: (upload
                 (: (speech-recognition.s2t
                     (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio))) (<: (VocalsIn $l) Audio)))
                         (: (s (s z)) (VocalsIn $l))) Audio))
                    (TextIn "English")))
                (UniformResourceLocatorOfType (TextIn "English"))))
            (TextIn "Chinese"))))
      (: (sound-spleeter.DTLOutput.vocals (: (s z) (sound-spleeter.DTLOutput $l))) (VocalsIn $l)))
     (SongIn "Chinese")))

;; Type check part of the English to Chinese singing AI service composition
;; !(assertEqual
  !(bc &kb Nil (s z) (fromNumber 12)
      (: (λ (s z)
           ((λ (s (s z))
              ((λ (s (s (s z)))
                 ((mixer.mix
                   (: (sound-spleeter.DTLOutput.accomp (: (s z) $t1368977))
                      $t1324258))
                  (: ((midi2voice-zh.singingZH (: (s (s (s z))) $t1426175))
                      (: (tomidi.a2m (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
                                                    (<: (VocalsIn $l) Audio)))
                                         (: (s (s z)) $t1478911))
                                        $t1460881))
                         $t1405639))
                     $t1278338)))
               (: (((machine-translation.translate
                     (: "English" $t1632159))
                    (: "Chinese" $t1623369))
                   (: (upload (: (speech-recognition.s2t
                                  (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
                                                 (<: (VocalsIn $l) Audio)))
                                      (: (s (s z)) $t1478911))
                                   $t1234567))
                                 $t1658822))
                      $t1608997))
                  $t1174780)))
            (: (sound-spleeter.DTLOutput.vocals
                (: (s z) $t1368977))
               $t980175)))
         $thrm))
  ;; (: (λ (s z)
  ;;      ((λ (s (s z))
  ;;         ((λ (s (s (s z)))
  ;;            ((mixer.mix
  ;;              (: (sound-spleeter.DTLOutput.accomp (: (s z) (sound-spleeter.DTLOutput $l))) Instrumental))
  ;;             (: ((midi2voice-zh.singingZH (: (s (s (s z))) (TextIn "Chinese")))
  ;;                 (: (tomidi.a2m
  ;;                     (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
  ;;                                    (<: (VocalsIn $l) Audio)))
  ;;                         (: (s (s z)) (VocalsIn $l))) Audio))
  ;;                    MusicalInstrumentDigitalInterface))
  ;;                (VocalsIn "Chinese"))))
  ;;          (: (((machine-translation.translate
  ;;                (: "English" NaturalLanguage))
  ;;               (: "Chinese" NaturalLanguage))
  ;;              (: (upload
  ;;                  (: (speech-recognition.s2t
  ;;                      (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
  ;;                                     (<: (VocalsIn $l) Audio)))
  ;;                          (: (s (s z)) (VocalsIn $l))) Audio))
  ;;                     (TextIn "English")))
  ;;                 (UniformResourceLocatorOfType (TextIn "English"))))
  ;;             (TextIn "Chinese"))))
  ;;       (: (sound-spleeter.DTLOutput.vocals (: (s z) (sound-spleeter.DTLOutput $l)))
  ;;          (VocalsIn $l))))
  ;;    (-> (: $prfarg#3300734 (sound-spleeter.DTLOutput $l)) (SongIn "Chinese"))))

;; Type check part of the English to Chinese singing AI service composition
!(assertEqual
  (bc &kb (Cons (: z $t3200004) Nil) (s z) (fromNumber 13)
      (: ((λ (s z)
            ((λ (s (s z))
               ((λ (s (s (s z)))
                  ((mixer.mix
                    (: (sound-spleeter.DTLOutput.accomp (: (s z) $t1368977))
                       $t1324258))
                   (: ((midi2voice-zh.singingZH (: (s (s (s z))) $t1426175))
                       (: (tomidi.a2m (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
                                                     (<: (VocalsIn $l) Audio)))
                                          (: (s (s z)) $t1478911))
                                         $t1460881))
                          $t1405639))
                      $t1278338)))
                (: (((machine-translation.translate
                      (: "English" $t1632159))
                     (: "Chinese" $t1623369))
                    (: (upload (: (speech-recognition.s2t
                                   (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
                                                  (<: (VocalsIn $l) Audio)))
                                       (: (s (s z)) $t1478911))
                                      $t1234567))
                                  $t1658822))
                       $t1608997))
                   $t1174780)))
             (: (sound-spleeter.DTLOutput.vocals
                 (: (s z) $t1368977))
                $t980175)))
          (: (sound-spleeter.spleeter (: z $t3200004)) $t527299))
         $thrm))
  (: ((λ (s z)
        ((λ (s (s z))
           ((λ (s (s (s z)))
              ((mixer.mix
                (: (sound-spleeter.DTLOutput.accomp (: (s z) (sound-spleeter.DTLOutput $l)))
                   Instrumental))
               (: ((midi2voice-zh.singingZH (: (s (s (s z))) (TextIn "Chinese")))
                   (: (tomidi.a2m
                       (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
                                      (<: (VocalsIn $l) Audio)))
                           (: (s (s z)) (VocalsIn $l))) Audio))
                      MusicalInstrumentDigitalInterface))
                  (VocalsIn "Chinese"))))
            (: (((machine-translation.translate
                  (: "English" NaturalLanguage))
                 (: "Chinese" NaturalLanguage))
                (: (upload
                    (: (speech-recognition.s2t
                        (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
                                       (<: (VocalsIn $l) Audio)))
                            (: (s (s z)) (VocalsIn $l))) Audio))
                       (TextIn "English")))
                   (UniformResourceLocatorOfType (TextIn "English"))))
               (TextIn "Chinese"))))
         (: (sound-spleeter.DTLOutput.vocals (: (s z) (sound-spleeter.DTLOutput $l))) (VocalsIn $l))))
      (: (sound-spleeter.spleeter (: z (SongIn $l))) (sound-spleeter.DTLOutput $l)))
     (SongIn "Chinese")))

;; Type check the totality of the English to Chinese singing AI service composition
!(assertEqual
  (bc &kb Nil z (fromNumber 14)
      (: (λ z
           ((λ (s z)
              ((λ (s (s z))
                 ((λ (s (s (s z)))
                    ((mixer.mix
                      (: (sound-spleeter.DTLOutput.accomp (: (s z) $t1368977))
                         $t1324258))
                     (: ((midi2voice-zh.singingZH (: (s (s (s z))) $t1426175))
                         (: (tomidi.a2m (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
                                                       (<: (VocalsIn $l) Audio)))
                                            (: (s (s z)) $t1478911))
                                           $t1460881))
                            $t1405639))
                        $t1278338)))
                  (: (((machine-translation.translate
                        (: "English" $t1632159))
                       (: "Chinese" $t1623369))
                      (: (upload (: (speech-recognition.s2t
                                     (: ((coerce (: ((STTrans (: VIV (<: (VocalsIn $l) Vocals))) (: VA (<: Vocals Audio)))
                                                    (<: (VocalsIn $l) Audio)))
                                         (: (s (s z)) $t1478911))
                                        $t1234567))
                                    $t1658822))
                         $t1608997))
                     $t1174780)))
               (: (sound-spleeter.DTLOutput.vocals
                   (: (s z) $t1368977))
                  $t980175)))
            (: (sound-spleeter.spleeter (: z $t3200004)) $t527299)))
         (-> (: $s (SongIn "English")) (SongIn "Chinese"))))
  (: (λ z
       ((λ (s z)
          ((λ (s (s z))
             ((λ (s (s (s z)))
                ((mixer.mix
                  (: (sound-spleeter.DTLOutput.accomp
                      (: (s z) (sound-spleeter.DTLOutput "English")))
                     Instrumental))
                 (: ((midi2voice-zh.singingZH
                      (: (s (s (s z))) (TextIn "Chinese")))
                     (: (tomidi.a2m
                         (: ((coerce
                              (: ((STTrans (: VIV (<: (VocalsIn "English") Vocals))) (: VA (<: Vocals Audio)))
                                 (<: (VocalsIn "English") Audio)))
                             (: (s (s z)) (VocalsIn "English"))) Audio))
                        MusicalInstrumentDigitalInterface))
                    (VocalsIn "Chinese"))))
              (: (((machine-translation.translate
                    (: "English" NaturalLanguage))
                   (: "Chinese" NaturalLanguage))
                  (: (upload
                      (: (speech-recognition.s2t
                          (: ((coerce
                               (: ((STTrans (: VIV (<: (VocalsIn "English") Vocals))) (: VA (<: Vocals Audio)))
                                  (<: (VocalsIn "English") Audio)))
                              (: (s (s z))
                                 (VocalsIn "English"))) Audio))
                         (TextIn "English")))
                     (UniformResourceLocatorOfType (TextIn "English"))))
                 (TextIn "Chinese"))))
           (: (sound-spleeter.DTLOutput.vocals (: (s z) (sound-spleeter.DTLOutput "English")))
              (VocalsIn "English"))))
        (: (sound-spleeter.spleeter (: z (SongIn "English")))
           (sound-spleeter.DTLOutput "English"))))
     (-> (: $s (SongIn "English")) (SongIn "Chinese"))))
