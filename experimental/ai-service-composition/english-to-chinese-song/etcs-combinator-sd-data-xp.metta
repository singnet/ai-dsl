;; Like etcs-combinator-sd-xp.metta but contains a small ontology with
;; a Data upper type to make the difference between data and function.
;;
;; Combinators are obtained from the Data.Aviary.Birds Haskell package
;; https://hackage.haskell.org/package/data-aviary-0.4.0/docs/Data-Aviary-Birds.html

;;;;;;;;;
;; Nat ;;
;;;;;;;;;

;; Define Nat
(: Nat Type)
(: Z Nat)
(: S (-> Nat Nat))

;; Define <=
(: <= (-> $a $a Bool))
(= (<= $x $y) (or (< $x $y) (== $x $y)))

;; Define cast functions between Nat and Number
(: fromNumber (-> Number Nat))
(= (fromNumber $n) (if (<= $n 0) Z (S (fromNumber (- $n 1)))))
(: fromNat (-> Nat Number))
(= (fromNat Z) 0)
(= (fromNat (S $k)) (+ 1 (fromNat $k)))

;;;;;;;;;;;;;;;;;;;;;;
;; Backward chainer ;;
;;;;;;;;;;;;;;;;;;;;;;

;; Curried Backward Chainer with dependent types (no lambda
;; abstraction here, combinatory logic is used instead).
;;
;; The arguments of the backward chainer are:
;;
;; * Knowledge base: pointer to a space containing axioms and rules in
;;   the format (: <NAME> <RULE>).  Note that rules are explicitely
;;   curried, meaning that a rule with two premises is represented by
;;
;;   (: <NAME> (-> <PREMISE1> (-> <PREMISE2> <CONCLUSION>)))
;;
;;   In addition, each premise must be an inline typing relationship,
;;   to represent dependent types.  It should be noted that such
;;   typing relationship must be provided even if the witness is not
;;   present in the rest of the definition.  For instance <PREMISE1>
;;   would have the format
;;
;;   (: <TERM1> <TYPE1>)
;;
;; * Maximum depth: maximum depth of the generated proof tree.
;;
;; * Query: a metta term of the form (: <PROOF> <THEOREM>) where
;;   <PROOF> and <THEOREM> may contain free variables that may be
;;   filled by the backward chainer.
;;
;; A result is the query with its variables grounded, fully or
;; partially.  If multiple results are possible, they are returned as
;; a superposition.
(: bc (-> $a                            ; Knowledge base space
          Nat                           ; Maximum depth
          $b                            ; Query
          $b))                          ; Result

;; Base cases: match the knowledge base
(= (bc $kb $_ (: $prf $thrm))
   (match $kb (: $prf $thrm) (: $prf $thrm)))

;; Recursive steps: proof application
(= (bc $kb (S $k) (: ($prfabs $prfarg) $thrm))
   (let* (((: $prfabs (-> (: $prfarg $prms) $thrm))
           (bc $kb $k (: $prfabs (-> (: $prfarg $prms) $thrm))))
          ((: $prfarg $prms)
           (bc $kb $k (: $prfarg $prms))))
     (: ($prfabs $prfarg) $thrm)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Knowledge and rule base ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

!(bind! &kb (new-space))

;;;;;;;;;;;;;;
;; Ontology ;;
;;;;;;;;;;;;;;

;; The ontology is simply composed of an upper type Data which all
;; other data types are subtype of.
!(add-atom &kb (: SOD (<: (sound-spleeter.DTLOutput $l) Data)))
!(add-atom &kb (: VID (<: (VocalsIn $l) Data)))
!(add-atom &kb (: IND (<: Instrumental Data)))
!(add-atom &kb (: SID (<: (SongIn $l) Data)))

;;;;;;;;;;;;;;
;; Services ;;
;;;;;;;;;;;;;;

;; The following is partly obtained from crawling the actual
;; SingularityNET market place, partly made up to simplify the
;; composition.

;; TODO: for now we paste the content of
;; english-song-to-chinese-song-services.metta here because the import
;; operation imports the stdlib as well and let stdlib functions being
;; used as rules and axioms by the backward chainer.
;;
;; Also, for the sake of simplicity the names have been shorten by
;; removing the organization.  For instance
;;
;; sound-spleeter.DTLOutput.vocals
;;
;; becomes
;;
;; vocals
;;
;; Finally constructors and destructors are avoided when possible.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Services involved in creating a composite service to turn English
;; singing into Chinese singing.
;;
;; The service specifications are obtained from the output of
;;
;; ./gen-snet-marketplace-metta.sh naint.machine-translation naint.midi2voice-zh snet.sound-spleeter snet.speech-recognition
;;
;; then curated to retain only the information about the type
;; signatures of service calls.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MeTTa representation, generated by protobuf-metta
;;
;; Protobuf file: sound_spleeter.proto
;; Protobuf syntax: proto3
;; Prefix: snet.sound-spleeter
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Define sound-spleeter.DTLOutput access functions

;; Define sound-spleeter.DTLOutput.vocals
!(add-atom &kb (: vocals
                  (-> (: $out (sound-spleeter.DTLOutput $l))
                      (VocalsIn $l))))

;; Define sound-spleeter.DTLOutput.accomp
!(add-atom &kb (: accomp
                  (-> (: $out (sound-spleeter.DTLOutput $l))
                      Instrumental)))

;;;;;;;;;;;;;;
;; Services ;;
;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;
;; SoundSpleeter ;;
;;;;;;;;;;;;;;;;;;;

;; Define DTL version of sound-spleeter.spleeter
!(add-atom &kb (: spleeter
                  (-> (: $song (SongIn $l))
                      ;; We reuse the spleeter Output type to hold
                      ;; a pair of Audio
                      (sound-spleeter.DTLOutput $l))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; English vocals to Chinese vocals ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; This made-up service, takes vocals in English and directly
;; translate then into Chinsese, preserving melody and tempo.

;; Method
!(add-atom &kb (: translate
                  (-> (: $en-vocals (VocalsIn "English"))
                      (VocalsIn "Chinese"))))

;;;;;;;;;;;
;; Mixer ;;
;;;;;;;;;;;

;; DTL version
!(add-atom &kb (: mix
                  (-> (: $inst Instrumental)
                      (-> (: $voc (VocalsIn $l))
                          (SongIn $l)))))

;;;;;;;;;;;;;;;;;
;; Combinators ;;
;;;;;;;;;;;;;;;;;

;; NEXT: add implicit arrow type, =>

;; NEXT: consider moving subtype of Data in definition

;; NEXT: consider moving rules to dedicated backward chainer.  Maybe
;; even uncurried version.

;; Name: Bluebird
;; Description: Sequential composition
;; Type: (b -> c) -> (a -> b) -> a -> c
;; Definition: bluebird f g x = f (g x)
;; Symbol: .
;; Diagram:
;; -a-b-c->
!(add-atom &kb (: .
                  (-> (: $aD (<: $a Data))
                      (-> (: $bD (<: $b Data))
                          (-> (: $cD (<: $c Data))
                              (-> (: $f (-> (: $y $b) $c))
                                  (-> (: $g (-> (: $x $a) $b))
                                      (-> (: $x $a) $c))))))))

;; Name: Phoenix
;; Description: Split then join
;; Type: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
;; Definition: phoenix f g h x = f (g x) (h x)
;; Symbol: Φ (LaTeX: \Phi, Math Emacs: \upPhi)
;; Diagram:
;;    b
;;   / \
;; -a   d->
;;   \ /
;;    c
!(add-atom &kb (: Φ
                  (-> (: $aD (<: $a Data))
                      (-> (: $bD (<: $b Data))
                          (-> (: $cD (<: $c Data))
                              (-> (: $dD (<: $c Data))
                                  (-> (: $f (-> (: $y $b) (-> (: $z $c) $d)))
                                      (-> (: $g (-> (: $x $a) $b))
                                          (-> (: $h (-> (: $x $a) $c))
                                              (-> (: $x $a) $d))))))))))

;;;;;;;;;;;;;;;;;;;;;
;; Reduction rules ;;
;;;;;;;;;;;;;;;;;;;;;

;; Composition to application
(= ((((((. $aD) $bD) $cD) $g) $f) $x) ($g ($f $x)))

;; Right associate composition, meaning
;;
;; h . g . f
;;
;; should be represented as
;;
;; h . (g . f)
;;
;; or in MeTTa
;;
;; ((. h) ((. g) f))
;;
;; Thus anything deviating from that representation, such as
;;
;; (h . g) . f
;;
;; or in MeTTa
;;
;; ((. ((. h) g)) f)
;;
;; should be rewritten as
;;
;; ((. h) ((. g) f))
;;
;; The reason left associativity is choosen as default over right
;; associativity is because in prefix notation the former is easier to
;; read (to me anyway).
(= (((((. $aD) $bD) $cD) (((((. $bD) $cD) $dD) $h) $g)) $f)
   (((((. $bD) $cD) $dD) $h) (((((. $aD) $bD) $cD) $g) $f)))

;; ;; The following sequential compositions
;; ;;
;; ;; (. ((. f) g))
;; ;; ((. (. f)) (. g))
;; ;;
;; ;; are likely equivalent according to the backward chainer, indeed
;; ;; inferring their type signatures leads in both cases to
;; ;;
;; ;; (a -> A) -> (a -> C)
;; ;;
;; ;; where A is the domain of g and C is the codomain of f.  We can see
;; ;; that it is similar to . but applies the composition to higher level
;; ;; functions rather than concrete data.  Thus maybe it could also be
;; ;; avoided by limiting sequential composition to concrete data,
;; ;; a.k.a. limited to first order.
;; ;;
;; ;; To get an intuition behind why they are seemingly equivalent, let
;; ;; us attempt to manually derive their type signatures.  Let the type
;; ;; signatures of f and g be
;; ;;
;; ;; f : B -> C
;; ;; g : A -> B
;; ;;
;; ;; In the following a, b and c are type variables scoped only within
;; ;; their own line.  To avoid naming collision we append primes, such
;; ;; as a', etc.  Recall that
;; ;;
;; ;; . : (b -> c) -> (a -> b) -> a -> c
;; ;;
;; ;; We can establish the following type relationships:
;; ;;
;; ;; 1. For (. ((. f) g))
;; ;;
;; ;; ((. f) g) : A -> C
;; ;;
;; ;; Thus
;; ;;
;; ;; (. ((. f) g)) : (a -> A) -> (a -> C)
;; ;;
;; ;; 2. For ((. (. f)) (. g))
;; ;;
;; ;; (. f) : (a -> B) -> a -> C
;; ;;
;; ;; Thus with bindings {b↦(a' -> B), c↦(a' -> C)}
;; ;;
;; ;; (. (. f)) : (a -> (a' -> B)) -> (a -> (a' -> C))
;; ;;
;; ;; Also
;; ;;
;; ;; (. g) : (a -> A) -> a -> B
;; ;;
;; ;; Thus, with bindings {a↦(a'' -> A), a'↦a''}
;; ;;
;; ;; ((. (. f)) (. g)) : (a'' -> A) -> (a'' -> C)
;; ;;
;; ;; Which is alpha-equivalent to
;; ;;
;; ;; ((. (. f)) (. g)) : (a -> A) -> (a -> C)
;; ;;
;; ;; Thus
;; ;;
;; ;; (. ((. f) g))
;; ;;
;; ;; is equivalent (as far as their type signature is concerned anyway)
;; ;; to
;; ;;
;; ;; ((. (. f)) (. g))
;; ;;
;; ;; Even after doing the derivation manually, I still don't understand
;; ;; why they are equivalent.  Let us prove it by showing that
;; ;;
;; ;; ∀x,y (((. ((. f) g)) x) y) == ((((. (. f)) (. g)) x) y)
;; ;;
;; ;; 1. Let us β-reduce (((. ((. f) g)) x) y) to normal form
;; ;;
;; ;; First, it reduces to
;; ;;
;; ;; (((. f) g) (x y))
;; ;;
;; ;; which finaly reduces to
;; ;;
;; ;; (f (g (x y)))
;; ;;
;; ;; 2. Let us β-reduce ((((. (. f)) (. g)) x) y) to normal form
;; ;;
;; ;; First, it reduces to
;; ;;
;; ;; (((. f) ((. g) x)) y)
;; ;;
;; ;; which reduces to
;; ;;
;; ;; (f (((. g) x) y))
;; ;;
;; ;; which finally reduces to
;; ;;
;; ;; (f (g (x y)))
;; ;;
;; ;; I still don't understand, but since both reduce to the same normal
;; ;; form, they are definitely equivalent, we can thus safely introduce
;; ;; the following reduction rule
;; (= ((. (. $f)) (. $g)) (. ((. $f) $g)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Remove implicit arguments ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Remove implicit arguments, that is arguments proving that the types
;; involved in combinators are subtypes of Data.  Only works on a
;; closed expression.
(: remove-implicit-arguments (-> $a $a))
(= (remove-implicit-arguments $term)
   (case (get-metatype $term)
     ((Symbol $term)
      (Variable $term)
      (Grounded $term)
      (Expression (case $term
                    (((((((. $aD) $bD) $cD) $f) $g)
                      (let* (($νf (remove-implicit-arguments $f))
                             ($νg (remove-implicit-arguments $g)))
                        ((. $νf) $νg)))
                     ((((((((Φ $aD) $bD) $cD) $dD) $f) $g) $h)
                      (let* (($νf (remove-implicit-arguments $f))
                             ($νg (remove-implicit-arguments $g))
                             ($νh (remove-implicit-arguments $h)))
                        ((((Φ $νf) $νg)) $νh)))))))))

;; Test remove-implicit-arguments
!(assertEqual
  (remove-implicit-arguments SD)
  SD)
!(assertEqual
  (remove-implicit-arguments (((((. SD) VD) VD) translate) vocals))
  ((. translate) vocals))
!(assertEqual
  (remove-implicit-arguments
   (((((. SID) SOD) SID)
     (((((((Φ SOD) IND) VID) VID) mix) accomp)
      (((((. SOD) VID) VID) translate) vocals))) spleeter))
  ((. ((((Φ mix) accomp)) ((. translate) vocals))) spleeter))

;; NEXT: try to identify reduction rules to simplify the following candidates

!(assertEqual
  (remove-implicit-arguments
   (((((. SID) SOD) SID)
     (((((. SOD) SOD) SID) (((((((Φ SOD) IND) VID) VID) mix) accomp) vocals))
      (((((. SOD) SID) SOD) spleeter)
       (((((((Φ SOD) IND) VID) VID) mix) accomp) (((((. SOD) VID) VID) translate) vocals))))) spleeter))
  ((. ((. ((((Φ mix) accomp)) vocals)) ((. spleeter) ((((Φ mix) accomp)) ((. translate) vocals))))) spleeter))

!(assertEqual
  (remove-implicit-arguments
   (((((. SID) SOD) SID)
     (((((. SOD) SOD) SID) (((((((Φ SOD) IND) VID) VID) mix) accomp) vocals))
      (((((. SOD) SID) SOD) spleeter)
       (((((((Φ SOD) IND) VID) VID) mix) accomp)
        (((((. SOD) VID) VID) translate) vocals))))) spleeter))
  ((. ((. ((((Φ mix) accomp)) vocals)) ((. spleeter) ((((Φ mix) accomp)) ((. translate) vocals)))))
   spleeter))

!(assertEqual
  (remove-implicit-arguments
   (((((. SID) SOD) SID)
     (((((. SOD) SOD) SID) (((((((Φ SOD) IND) VID) VID) mix) accomp) vocals))
      (((((. SOD) SID) SOD) spleeter)
       (((((((Φ SOD) IND) VID) VID) mix) accomp)
        (((((. SOD) VID) VID) translate) vocals)))))
    (((((. SID) SOD) SOD)
      (((((. SOD) SID) SOD) spleeter)
       (((((((Φ SOD) IND) VID) VID) mix) accomp) vocals))) spleeter)))
  ((. ((. ((((Φ mix) accomp)) vocals)) ((. spleeter) ((((Φ mix) accomp)) ((. translate) vocals)))))
   ((. ((. spleeter) ((((Φ mix) accomp)) vocals))) spleeter)))

!(assertEqual
  (remove-implicit-arguments
   (((((. SID) SOD) SID)
     (((((. SOD) SOD) SID) (((((((Φ SOD) IND) VID) VID) mix) accomp) vocals))
      (((((. SOD) SID) SOD) spleeter)
       (((((((Φ SOD) IND) VID) VID) mix) accomp) vocals))))
    (((((. SID) SOD) SOD)
      (((((. SOD) SID) SOD) spleeter)
       (((((((Φ SOD) IND) VID) VID) mix) accomp)
        (((((. SOD) VID) VID) translate) vocals)))) spleeter)))
  ((. ((. ((((Φ mix) accomp)) vocals)) ((. spleeter) ((((Φ mix) accomp)) vocals))))
   ((. ((. spleeter) ((((Φ mix) accomp)) ((. translate) vocals)))) spleeter)))

!(assertEqual
  (remove-implicit-arguments
   (((((. SID) SOD) SID)
     (((((. SOD) SOD) SID) (((((((Φ SOD) IND) VID) VID) mix) accomp) vocals))
      (((((. SOD) SID) SOD) spleeter)
       (((((((Φ SOD) IND) VID) VID) mix) accomp) vocals))))
    (((((. SID) SOD) SOD)
      (((((. SOD) SID) SOD) spleeter)
       (((((((Φ SOD) IND) VID) VID) mix) accomp) vocals)))
     (((((. SID) SOD) SOD)
       (((((. SOD) SID) SOD) spleeter)
        (((((((Φ SOD) IND) VID) VID) mix) accomp)
         (((((. SOD) VID) VID) translate) vocals)))) spleeter))))
  ((. ((. ((((Φ mix) accomp)) vocals)) ((. spleeter) ((((Φ mix) accomp)) vocals))))
   ((. ((. spleeter) ((((Φ mix) accomp)) vocals)))
    ((. ((. spleeter) ((((Φ mix) accomp)) ((. translate) vocals)))) spleeter))))

!(assertEqual
  (remove-implicit-arguments (((((. SOD) SID) SID)
                               (((((((Φ SID) IND) VID) VID) mix)
                                 (((((. SID) SOD) IND) accomp) spleeter))
                                (((((. SID) SOD) VID) vocals) spleeter)))
                              (((((. SID) SOD) SID)
                                (((((. SOD) SOD) SID)
                                  (((((((Φ SOD) IND) VID) VID) mix) accomp) vocals))
                                 (((((. SOD) SID) SOD) spleeter)
                                  (((((((Φ SOD) IND) VID) VID) mix) accomp) vocals))))
                               (((((. SID) SID) SOD)
                                 (((((. SID) SID) SOD) spleeter)
                                  (((((((Φ SID) IND) VID) VID) mix)
                                    (((((. SID) SOD) IND) accomp) spleeter))
                                   (((((. SID) SOD) VID) vocals) spleeter))))
                                (((((. SID) SID) SID)
                                  (((((((Φ SID) IND) VID) VID) mix)
                                    (((((. SID) SOD) IND) accomp) spleeter))
                                   (((((. SID) VID) VID) translate)
                                    (((((. SID) SOD) VID) vocals) spleeter))))
                                 (((((. SID) SOD) SID)
                                   (((((((Φ SOD) IND) VID) VID) mix) accomp) vocals))
                                  (((((. SID) SID) SOD) spleeter)
                                   (((((((Φ SID) IND) VID) VID) mix)
                                     (((((. SID) SOD) IND) accomp) spleeter))
                                    (((((. SID) SOD) VID) vocals) spleeter)))))))))
  ((. ((((Φ mix) ((. accomp) spleeter))) ((. vocals) spleeter)))
   ((. ((. ((((Φ mix) accomp)) vocals)) ((. spleeter) ((((Φ mix) accomp)) vocals))))
    ((. ((. spleeter) ((((Φ mix) ((. accomp) spleeter))) ((. vocals) spleeter))))
     ((. ((((Φ mix) ((. accomp) spleeter))) ((. translate) ((. vocals) spleeter))))
      ((. ((((Φ mix) accomp)) vocals))
       ((. spleeter) ((((Φ mix) ((. accomp) spleeter))) ((. vocals) spleeter)))))))))

;;;;;;;;;;
;; Test ;;
;;;;;;;;;;

;; The following MeTTa program represents the AI service composition
;; for the English to Chinese song translation using the made-up
;; vocals-translator service.
;;
;; (= (english-song-to-chinese-song $input)
;;    (let $spleeter-output (spleeter $input)
;;      ((mix (accomp $spleeter-output))
;;       (translate (vocals $spleeter-output)))))
;;
;; It should be equivalent to the following combinatory logic program
;;
;; (. (Φ mix accomp (. translate vocals)) spleeter)
;;
;; or with all parentheses
;;
;; ((. (((Φ mix) accomp) ((. translate) vocals))) spleeter)

;; ;; Infer the type of .
;; ;; TODO: re-enable once alpha equivalence is supported
;; !(assertEqual
;;   (bc &kb (fromNumber 0) (: . $t))
;;   (: . (-> (: $aD (<: $a Data))
;;            (-> (: $bD (<: $b Data))
;;                (-> (: $cD (<: $c Data))
;;                    (-> (: $f (-> (: $y $b) $c))
;;                        (-> (: $g (-> (: $x $a) $b))
;;                            (-> (: $x $a) $c))))))))

;; ;; Find all subtypes of Data
;; ;; TODO: re-enable once alpha equivalence is supported
;; !(assertEqualToResult
;;   (bc &kb (fromNumber 0) (: $prf (<: $s Data)))
;;   ((: IND (<: Instrumental Data))
;;    (: SID (<: (SongIn $l) Data))
;;    (: VID (<: (VocalsIn $l) Data))
;;    (: SOD (<: (sound-spleeter.DTLOutput $l) Data))))

;; ;; Infer the type of (((. $aD) $bD) $cD)
;; ;; TODO: re-enable once assert contain is supported
;; !(bc &kb (fromNumber 3) (: (((. $aD) $bD) $cD) $t))

;; ;; Infer the type of ((((. $aD) $bD) $cD) vocals)
;; ;; TODO: re-enable once assert contain is supported
;; !(bc &kb (fromNumber 4) (: ((((. $aD) $bD) $cD) translate) $t))

;; ;; Infer the type of ((. translate) vocals)
;; ;; TODO: re-enable once alpha-equivalence is supported
;; !(assertEqual
;;   (bc &kb (fromNumber 5) (: (((((. $aD) $bD) $cD) translate) vocals) $t))
;;   (: (((((. SOD) VID) VID) translate) vocals)
;;    (-> (: $x (sound-spleeter.DTLOutput "English")) (VocalsIn "Chinese"))))

;; Synthesize ((. translate) vocals)
!(assertEqual
  (bc &kb
      (fromNumber 5)
      (: $prg (-> (: $x (sound-spleeter.DTLOutput "English")) (VocalsIn "Chinese"))))
  (: (((((. SOD) VID) VID) translate) vocals)
     (-> (: $x (sound-spleeter.DTLOutput "English")) (VocalsIn "Chinese"))))

;; Synthesize (((Φ mix) accomp) ((. translate) vocals)) given a template
!(assertEqual
  (bc &kb
      (fromNumber 7)
      (: (((((((Φ $aD) $bD) $cD) $dD) $f) $g) $h)
         (-> (: $x (sound-spleeter.DTLOutput "English")) (SongIn "Chinese"))))
  (: (((((((Φ SOD) IND) VID) VID) mix) accomp)
      (((((. SOD) VID) VID) translate) vocals))
     (-> (: $x (sound-spleeter.DTLOutput "English")) (SongIn "Chinese"))))

;; Synthesize (((Φ mix) accomp) ((. translate) vocals)) from scratch
!(assertEqual
  (bc &kb
      (fromNumber 7)
      (: $prg (-> (: $x (sound-spleeter.DTLOutput "English")) (SongIn "Chinese"))))
  (: (((((((Φ SOD) IND) VID) VID) mix) accomp)
      (((((. SOD) VID) VID) translate) vocals))
     (-> (: $x (sound-spleeter.DTLOutput "English")) (SongIn "Chinese"))))

;; ;; Type check
;; ;;
;; ;;       (: (((((. SID) SOD) SID)
;; ;;            (((((((Φ SOD) IND) VID) VID) mix) accomp)
;; ;;             (((((. SOD) VID) VID) translate) vocals))) spleeter)
;; ;;          (-> (: $x (SongIn "English")) (SongIn "Chinese"))))
;; ;;
;; ;; TODO: re-enable once alpha-equivalence is supported
;; !(assertEqual
;;   (bc &kb
;;       (fromNumber 12)
;;       (: (((((. SID) SOD) SID)
;;            (((((((Φ SOD) IND) VID) VID) mix) accomp)
;;             (((((. SOD) VID) VID) translate) vocals))) spleeter)
;;          (-> (: $x (SongIn "English")) (SongIn "Chinese"))))
;;   (: (((((. SID) SOD) SID)
;;        (((((((Φ SOD) IND) VID) VID) mix) accomp)
;;         (((((. SOD) VID) VID) translate) vocals))) spleeter)
;;      (-> (: $x (SongIn "English")) (SongIn "Chinese"))))

;; Synthesize full AI service composition
;;
;; ((. (((Φ mix) accomp) ((. translate) vocals))) spleeter)
!(bc &kb
     (fromNumber 12)
     (: $prg (-> (: $x (SongIn "English")) (SongIn "Chinese"))))
