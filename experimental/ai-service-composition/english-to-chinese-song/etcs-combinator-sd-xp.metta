;; Scaled down version of etcs-combinator-xp.metta.
;;
;; Combinators are obtained from the Data.Aviary.Birds Haskell package
;; https://hackage.haskell.org/package/data-aviary-0.4.0/docs/Data-Aviary-Birds.html

;;;;;;;;;
;; Nat ;;
;;;;;;;;;

;; Define Nat
(: Nat Type)
(: Z Nat)
(: S (-> Nat Nat))

;; Define cast functions between Nat and Number
(: fromNumber (-> Number Nat))
(= (fromNumber $n) (if (<= $n 0) Z (S (fromNumber (- $n 1)))))
(: fromNat (-> Nat Number))
(= (fromNat Z) 0)
(= (fromNat (S $k)) (+ 1 (fromNat $k)))

;;;;;;;;;;;;;;;;;;;;;;
;; Backward chainer ;;
;;;;;;;;;;;;;;;;;;;;;;

;; Curried Backward Chainer with dependent types (no lambda
;; abstraction here, combinatory logic is used instead).
;;
;; The arguments of the backward chainer are:
;;
;; * Knowledge base: pointer to a space containing axioms and rules in
;;   the format (: <NAME> <RULE>).  Note that rules are explicitely
;;   curried, meaning that a rule with two premises is represented by
;;
;;   (: <NAME> (-> <PREMISE1> (-> <PREMISE2> <CONCLUSION>)))
;;
;;   In addition, each premise must be an inline typing relationship,
;;   to represent dependent types.  It should be noted that such
;;   typing relationship must be provided even if the witness is not
;;   present in the rest of the definition.  For instance <PREMISE1>
;;   would have the format
;;
;;   (: <TERM1> <TYPE1>)
;;
;; * Maximum depth: maximum depth of the generated proof tree.
;;
;; * Query: a metta term of the form (: <PROOF> <THEOREM>) where
;;   <PROOF> and <THEOREM> may contain free variables that may be
;;   filled by the backward chainer.
;;
;; A result is the query with its variables grounded, fully or
;; partially.  If multiple results are possible, they are returned as
;; a superposition.
(: bc (-> $a                            ; Knowledge base space
          Nat                           ; Maximum depth
          $b                            ; Query
          $b))                          ; Result

;; Base cases: match the knowledge base
(= (bc $kb $_ (: $prf $thrm))
   (match $kb (: $prf $thrm) (: $prf $thrm)))

;; Recursive steps: proof application
(= (bc $kb (S $k) (: ($prfabs $prfarg) $thrm))
   (let* (((: $prfabs (-> (: $prfarg $prms) $thrm))
           (bc $kb $k (: $prfabs (-> (: $prfarg $prms) $thrm))))
          ((: $prfarg $prms)
           (bc $kb $k (: $prfarg $prms))))
     (: ($prfabs $prfarg) $thrm)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Knowledge and rule base ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

!(bind! &kb (new-space))

;; The following is partly obtained from crawling the actual
;; SingularityNET market place, partly made up to simplify the
;; composition.

;; TODO: for now we paste the content of
;; english-song-to-chinese-song-services.metta here because the import
;; operation imports the stdlib as well and let stdlib functions being
;; used as rules and axioms by the backward chainer.
;;
;; Also, for the sake of simplicity the names have been shorten by
;; removing the organization.  For instance
;;
;; sound-spleeter.DTLOutput.vocals
;;
;; becomes
;;
;; vocals
;;
;; Finally constructors and destructors are avoided when possible.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Services involved in creating a composite service to turn English
;; singing into Chinese singing.
;;
;; The service specifications are obtained from the output of
;;
;; ./gen-snet-marketplace-metta.sh naint.machine-translation naint.midi2voice-zh snet.sound-spleeter snet.speech-recognition
;;
;; then curated to retain only the information about the type
;; signatures of service calls.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MeTTa representation, generated by protobuf-metta
;;
;; Protobuf file: sound_spleeter.proto
;; Protobuf syntax: proto3
;; Prefix: snet.sound-spleeter
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Define sound-spleeter.DTLOutput access functions

;; Define sound-spleeter.DTLOutput.vocals
!(add-atom &kb (: vocals
                  (-> (: $out (sound-spleeter.DTLOutput $l))
                      (VocalsIn $l))))

;; Define sound-spleeter.DTLOutput.accomp
!(add-atom &kb (: accomp
                  (-> (: $out (sound-spleeter.DTLOutput $l))
                      Instrumental)))

;;;;;;;;;;;;;;
;; Services ;;
;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;
;; SoundSpleeter ;;
;;;;;;;;;;;;;;;;;;;

;; Define DTL version of sound-spleeter.spleeter
!(add-atom &kb (: spleeter
                  (-> (: $song (SongIn $l))
                      ;; We reuse the spleeter Output type to hold
                      ;; a pair of Audio
                      (sound-spleeter.DTLOutput $l))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; English vocals to Chinese vocals ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; This made-up service, takes vocals in English and directly
;; translate then into Chinsese, preserving melody and tempo.

;; Method
!(add-atom &kb (: translate
                  (-> (: $en-vocals (VocalsIn "English"))
                      (VocalsIn "Chinese"))))

;;;;;;;;;;;
;; Mixer ;;
;;;;;;;;;;;

;; DTL version
!(add-atom &kb (: mix
                  (-> (: $inst Instrumental)
                      (-> (: $voc (VocalsIn $l))
                          (SongIn $l)))))

;;;;;;;;;;;;;;;;;
;; Combinators ;;
;;;;;;;;;;;;;;;;;

;; Name: Bluebird
;; Description: Sequential composition
;; Type: (b -> c) -> (a -> b) -> a -> c
;; Definition: bluebird f g x = f (g x)
;; Symbol: .
;; Diagram:
;; -a-b-c->
!(add-atom &kb (: .
                  (-> (: $f (-> (: $y $b) $c))
                      (-> (: $g (-> (: $x $a) $b))
                          (-> (: $x $a) $c)))))

;; Name: Phoenix
;; Description: Split then join
;; Type: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
;; Definition: phoenix f g h x = f (g x) (h x)
;; Symbol: Φ (LaTeX: \Phi, Math Emacs: \upPhi)
;; Diagram:
;;    b
;;   / \
;; -a   d->
;;   \ /
;;    c
!(add-atom &kb (: Φ
                  (-> (: $f (-> (: $y $b) (-> (: $z $c) $d)))
                      (-> (: $g (-> (: $x $a) $b))
                          (-> (: $h (-> (: $x $a) $c))
                              (-> (: $x $a) $d))))))



;;;;;;;;;;;;;;;;;;;;;
;; Reduction Proof ;;
;;;;;;;;;;;;;;;;;;;;;

;; Tools to help to prove correctness of reduction rules

;; The following reduction functions seem overly complicated but that
;; is to be able to call them on terms containing free variables,
;; i.e. it is not required to be called on a closed term.  For that
;; the reduction function can take any term, however it will return a
;; Maybe, thus a (Just <REDUCED>) if it matches, and Nothing
;; otherwise.
;;
;; So for instance instead of implementing reduction of . as
;;
;; (= (bluebird-reduce ((($d $g) $f) $x)) ($g ($f $x)))
;;
;; it is implemented using Maybe as shown below.

;; Reduce (((. g) f) x) to (g (f x))
(: bluebird-reduce (-> $a (Maybe $a)))
(= (bluebird-reduce $term)
   (case $term
     ((((($bluebird $g) $f) $x) (if (== $bluebird .)
                                    (Just ($g ($f $x)))
                                    Nothing))
      ($_ Nothing))))

;; Reduce ((((Φ f) g) h) x) to ((f (g x)) (h x))
(: phoenix-reduce (-> $a (Maybe $a)))
(= (phoenix-reduce $term)
   (case $term
     (((((($phoenix $f) $g) $h) $x) (if (== $phoenix Φ)
                                        (Just (($f ($g $x)) ($h $x)))
                                        Nothing))
      ($_ Nothing))))

;; Reduce any term to its normal form, in the λ-calculus sense
(: β-reduce (-> $a $a))
(= (β-reduce $term)
   (case (get-metatype $term)
     ;; Base cases
     ((Symbol $term)
      (Grounded $term)
      (Variable $term)
      (Expression
       (if (== $term ())
           ()
           ;; Recursive steps
           (case $term
             ;; Application
             ((($f $g) (let* (($νf (β-reduce $f))
                              ($νg (β-reduce $g)))
                         (if (and (== $νf $f) (== $νg $g))
                             ;; $f and $g are already reduced, try to
                             ;; match them to known reduction rules
                             (case (bluebird-reduce $term)
                               (((Just $r) $r)
                                (Nothing
                                 (case (phoenix-reduce $term)
                                   (((Just $r) $r)
                                    ;; No reduction rules applicable,
                                    ;; return unchanged
                                    (Nothing ($f $g))))
                                 )))
                             ;; $f and $g changed, so attempt to
                             ;; reduce their application once more
                             (β-reduce ($νf $νg)))))
              ;; Otherwise, return unchanged
              ($_ $term))))))))

;; Test bluebird β-reduction
!(assertEqual
  (β-reduce (((. $g) $f) $x))
  ($g ($f $x)))

;; Test phoenix β-reduction
!(assertEqual
  (β-reduce ((((Φ $f) $g) $h) $x))
  (($f ($g $x)) ($h $x)))

;; TODO: fix the following test

;; ;; Test reduction of left and right associative composition
;; !(assertEqual
;;   (β-reduce (((. ((. $h) $g)) $f) $x))
;;   (β-reduce (((. $h) ((. $g) $f)) $x))

;;;;;;;;;;;;;;;;;;;;;
;; Reduction Rules ;;
;;;;;;;;;;;;;;;;;;;;;

;; Bluebird β-reduction
(= (((. $g) $f) $x) ($g ($f $x)))

;; ;; Phoenix β-reduction.  That rules is not recommended because it
;; ;; results in a duplication of $x.
;; (= ((((Φ $f) $g) $h) $x) (($f ($g $x)) ($h $x)))

;; These tests allow to prove that the reduction rules are correct in
;; the sense that the reduced term, if applied to arguments, β-reduces
;; to the same term.  Note that in order to pass all combinator
;; β-reduction rules need to be enabled.

;; ;; Test that applying left associative composition reduces is
;; ;; equivalent to applying right associative composition.
;; !(assertEqual
;;   (((. ((. $h) $g)) $f) $x)
;;   (((. $h) ((. $g) $f)) $x))

;; ;; Test that applying (. (. $f)) (. $g)) twice is equivalent to
;; ;; applying (. ((. $f) $g)) twice.
;; !(assertEqual
;;   ((((. (. $f)) (. $g)) $x) $y)
;;   (((. ((. $f) $g)) $x) $y))

;; ;; Test that applying (((Φ ((. $f) $g)) $j) ((. $h) ((. $i) $j)))
;; ;; once is equivalent to (((Φ $f) ((. $g) $j)) ((. $h) ((. $i) $j)))
;; !(assertEqual
;;   ((((Φ ((. $f) $g)) $j) ((. $h) ((. $i) $j))) $x)
;;   ((((Φ $f) ((. $g) $j)) ((. $h) ((. $i) $j))) $x))

;; ;; Test that applying (((Φ $f) ((. $g) $j)) ((. $h) ((. $i) $j))) once
;; ;; is equivalent to ((. (((Φ $f) $g) ((. $h) $i))) $j)
;; !(assertEqual
;;   ((((Φ $f) ((. $g) $j)) ((. $h) ((. $i) $j))) $x)
;;   (((. (((Φ $f) $g) ((. $h) $i))) $j) $x))

;; ;; Test that applying ((. (((Φ $f) $g) ((. $h) $i))) $j)
;; !(assertEqual
;;   (((. (((Φ $f) $g) ((. $h) $i))) $j) $x)
;;   (((((Φ (Φ $f)) (. $g)) (. ((. $h) $i))) $j) $x))

;; Right associate composition, meaning
;;
;; h . g . f
;;
;; should be represented as
;;
;; h . (g . f)
;;
;; or in MeTTa
;;
;; ((. h) ((. g) f))
;;
;; Thus anything deviating from that representation, such as
;;
;; (h . g) . f
;;
;; or in MeTTa
;;
;; ((. ((. h) g)) f)
;;
;; should be rewritten as
;;
;; ((. h) ((. g) f))
;;
;; The reason left associativity is choosen as default over right
;; associativity is because in prefix notation the former is easier to
;; read (to me anyway).
(= ((. ((. $h) $g)) $f) ((. $h) ((. $g) $f)))

;; The following sequential compositions
;;
;; (. ((. f) g))
;; ((. (. f)) (. g))
;;
;; are likely equivalent according to the backward chainer, indeed
;; inferring their type signatures leads in both cases to
;;
;; (a -> A) -> (a -> C)
;;
;; where A is the domain of g and C is the codomain of f.  We can see
;; that it is similar to . but applies the composition to higher level
;; functions rather than concrete data.  Thus maybe it could also be
;; avoided by limiting sequential composition to concrete data,
;; a.k.a. limited to first order.
;;
;; To get an intuition behind why they are seemingly equivalent, let
;; us attempt to manually derive their type signatures.  Let the type
;; signatures of f and g be
;;
;; f : B -> C
;; g : A -> B
;;
;; In the following a, b and c are type variables scoped only within
;; their own line.  To avoid naming collision we append primes, such
;; as a', etc.  Recall that
;;
;; . : (b -> c) -> (a -> b) -> a -> c
;;
;; We can establish the following type relationships:
;;
;; 1. For (. ((. f) g))
;;
;; ((. f) g) : A -> C
;;
;; Thus
;;
;; (. ((. f) g)) : (a -> A) -> (a -> C)
;;
;; 2. For ((. (. f)) (. g))
;;
;; (. f) : (a -> B) -> a -> C
;;
;; Thus with bindings {b↦(a' -> B), c↦(a' -> C)}
;;
;; (. (. f)) : (a -> (a' -> B)) -> (a -> (a' -> C))
;;
;; Also
;;
;; (. g) : (a -> A) -> a -> B
;;
;; Thus, with bindings {a↦(a'' -> A), a'↦a''}
;;
;; ((. (. f)) (. g)) : (a'' -> A) -> (a'' -> C)
;;
;; Which is alpha-equivalent to
;;
;; ((. (. f)) (. g)) : (a -> A) -> (a -> C)
;;
;; Thus
;;
;; (. ((. f) g))
;;
;; is equivalent (as far as their type signature is concerned anyway)
;; to
;;
;; ((. (. f)) (. g))
;;
;; Even after doing the derivation manually, I still don't understand
;; why they are equivalent.  Let us prove it by showing that
;;
;; ∀x,y (((. ((. f) g)) x) y) == ((((. (. f)) (. g)) x) y)
;;
;; 1. Let us β-reduce (((. ((. f) g)) x) y) to normal form
;;
;; First, it reduces to
;;
;; (((. f) g) (x y))
;;
;; which finaly reduces to
;;
;; (f (g (x y)))
;;
;; 2. Let us β-reduce ((((. (. f)) (. g)) x) y) to normal form
;;
;; First, it reduces to
;;
;; (((. f) ((. g) x)) y)
;;
;; which reduces to
;;
;; (f (((. g) x) y))
;;
;; which finally reduces to
;;
;; (f (g (x y)))
;;
;; I still don't understand, but since both reduce to the same normal
;; form, they are definitely equivalent, we can thus safely introduce
;; the following reduction rule
(= ((. (. $f)) (. $g)) (. ((. $f) $g)))

;; Move sequential composition from aggregator to branch.
;;
;; (Φ (. f g) j (. h (. i j)))
;;
;; reduces to
;;
;; (Φ f (. g j) (. h (. i j)))
(= (((Φ ((. $f) $g)) $j) ((. $h) ((. $i) $j)))
   (((Φ $f) ((. $g) $j)) ((. $h) ((. $i) $j))))

;; Factorize sequential branches of phoenix.
;;
;; (Φ f (. g i) (. h i))
;;
;; reduces to
;;
;; (. (Φ f g h) i)
;;
;; For now the reduction rule is overfit to our situation, which is
;;
;; (Φ f (. g j) (. h (. i j)))
;;
;; reduces to
;;
;; (. (Φ f g (. h i)) j)
(= (((Φ $f) ((. $g) $j)) ((. $h) ((. $i) $j)))
   ((. (((Φ $f) $g) ((. $h) $i))) $j))

;; Simplify double phoenix (and other weird stuff I don't understand
;; but proven to be true, see test earlier above).  Note that when
;; phoenix β-reduction rule is enabled, the following is not
;; necessary.
(= ((((Φ (Φ $f)) (. $g)) (. ((. $h) $i))) $j)
   ((. (((Φ $f) $g) ((. $h) $i))) $j))

;;;;;;;;;;
;; Test ;;
;;;;;;;;;;

;; The following MeTTa program represents the AI service composition
;; for the English to Chinese song translation using the made-up
;; vocals-translator service.
;;
;; (= (english-song-to-chinese-song $input)
;;    (let $spleeter-output (spleeter $input)
;;      ((mix (accomp $spleeter-output))
;;       (translate (vocals $spleeter-output)))))
;;
;; It should be equivalent to the following combinatory logic program
;;
;; (. (Φ mix accomp (. translate vocals)) spleeter)
;;
;; or with all parentheses
;;
;; ((. (((Φ mix) accomp) ((. translate) vocals))) spleeter)

;; Synthesize the full AI service composition
!(let $results (collapse
                (bc &kb
                    (fromNumber 5)
                    (: $prg (-> (: $x (SongIn "English")) (SongIn "Chinese")))))
   (unique (superpose $results)))
